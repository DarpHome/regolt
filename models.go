package regolt

import (
	"encoding/json"
	"time"
)

const iso8601Template = "2006-01-02T15:04:05-0700"

// TODO: CSS colour type

type AutumnFileMetadataType string

const (
	AutumnFileMetadataTypeFile  AutumnFileMetadataType = "File"
	AutumnFileMetadataTypeText  AutumnFileMetadataType = "Text"
	AutumnFileMetadataTypeImage AutumnFileMetadataType = "Image"
	AutumnFileMetadataTypeVideo AutumnFileMetadataType = "Video"
	AutumnFileMetadataTypeAudio AutumnFileMetadataType = "Audio"
)

type AutumnFileMetadata struct {
	Type   AutumnFileMetadataType `json:"type"`
	Width  int                    `json:"width"`
	Height int                    `json:"height"`
}

// Representation of a File on Revolt Generated by Autumn
type AutumnFile struct {
	// Unique ID
	ID string `json:"_id"`
	// Tag / bucket this file was uploaded to
	Tag string `json:"tag"`
	// Original filename
	Filename string `json:"filename"`
	// Metadata associated with file
	Metadata AutumnFileMetadata `json:"metadata"`
	// Raw content type of this file
	ContentType string `json:"content_type"`
	// Size of this file (in bytes)
	Size int `json:"size"`
	// Whether this file was deleted
	Deleted *bool `json:"deleted"`
	// Whether this file was reported
	Reported  *bool `json:"reported"`
	MessageID ULID  `json:"message_id"`
	UserID    ULID  `json:"user_id"`
	ServerID  ULID  `json:"server_id"`
	// ID of the object this file is associated with
	ObjectID ULID `json:"object_id"`
}

type OptimizedAutumnFileMetadataType int

const (
	OptimizedAutumnFileMetadataTypeUnknown OptimizedAutumnFileMetadataType = iota
	OptimizedAutumnFileMetadataTypeFile
	OptimizedAutumnFileMetadataTypeText
	OptimizedAutumnFileMetadataTypeImage
	OptimizedAutumnFileMetadataTypeVideo
	OptimizedAutumnFileMetadataTypeAudio
)

func (s AutumnFileMetadataType) ToOptimized() OptimizedAutumnFileMetadataType {
	switch s {
	case AutumnFileMetadataTypeFile:
		return OptimizedAutumnFileMetadataTypeFile
	case AutumnFileMetadataTypeText:
		return OptimizedAutumnFileMetadataTypeText
	case AutumnFileMetadataTypeImage:
		return OptimizedAutumnFileMetadataTypeImage
	case AutumnFileMetadataTypeVideo:
		return OptimizedAutumnFileMetadataTypeVideo
	case AutumnFileMetadataTypeAudio:
		return OptimizedAutumnFileMetadataTypeAudio
	}
	return OptimizedAutumnFileMetadataTypeUnknown
}

type OptimizedAutumnFileMetadata struct {
	Type   OptimizedAutumnFileMetadataType
	Width  int
	Height int
}

func (o *AutumnFileMetadata) ToOptimized() *OptimizedAutumnFileMetadata {
	return &OptimizedAutumnFileMetadata{
		Type:   o.Type.ToOptimized(),
		Width:  o.Width,
		Height: o.Height,
	}
}

type OptimizedAutumnFileFlags int

const (
	OptimizedAutumnFileFlagsDeleted OptimizedAutumnFileFlags = 1 << (0 + iota)
	OptimizedAutumnFileFlagsIsDeletedNil
	OptimizedAutumnFileFlagsReported
	OptimizedAutumnFileFlagsIsReportedNil
)

type OptimizedAutumnFile struct {
	ID          string
	Tag         string
	Filename    string
	Metadata    *OptimizedAutumnFileMetadata
	ContentType string
	Size        int
	Flags       OptimizedAutumnFileFlags
	MessageID   ULID
	UserID      ULID
	ServerID    ULID
	ObjectID    ULID
}

func (o *AutumnFile) ToOptimized() *OptimizedAutumnFile {
	r := &OptimizedAutumnFile{
		ID:          o.ID,
		Tag:         o.Tag,
		Filename:    o.Filename,
		Metadata:    o.Metadata.ToOptimized(),
		ContentType: o.ContentType,
		Size:        o.Size,
		MessageID:   o.MessageID,
		UserID:      o.UserID,
		ServerID:    o.ServerID,
		ObjectID:    o.ObjectID,
	}
	if o.Deleted != nil {
		if *o.Deleted {
			r.Flags |= OptimizedAutumnFileFlagsDeleted
		}
	} else {
		r.Flags |= OptimizedAutumnFileFlagsIsDeletedNil
	}
	if o.Reported != nil {
		if *o.Reported {
			r.Flags |= OptimizedAutumnFileFlagsReported
		}
	} else {
		r.Flags |= OptimizedAutumnFileFlagsIsReportedNil
	}
	return r
}

type RelationshipStatus string

const (
	RelationshipStatusNone         RelationshipStatus = "None"
	RelationshipStatusUser         RelationshipStatus = "User"
	RelationshipStatusFriend       RelationshipStatus = "Friend"
	RelationshipStatusOutgoing     RelationshipStatus = "Outgoing"
	RelationshipStatusIncoming     RelationshipStatus = "Incoming"
	RelationshipStatusBlocked      RelationshipStatus = "Blocked"
	RelationshipStatusBlockedOther RelationshipStatus = "BlockedOther"
)

type UserRelation struct {
	UserID ULID `json:"_id"`
	// User's relationship with another user (or themselves)
	Status RelationshipStatus `json:"status"`
}

type UserBadges int

const (
	UserBadgesDeveloper UserBadges = 1 << (0 + iota)
	UserBadgesTranslator
	UserBadgesSupporter
	UserBadgesResponsibleDisclosure
	UserBadgesFounder
	UserBadgesPlatformModeration
	UserBadgesActiveSupporter
	UserBadgesPaw
	UserBadgesEarlyAdopter
	UserBadgesRelevantJokeBadge1
)

type Presence string

const (
	PresenceOnline    Presence = "Online"
	PresenceIdle      Presence = "Idle"
	PresenceFocus     Presence = "Focus"
	PresenceBusy      Presence = "Busy"
	PresenceInvisible Presence = "Invisible"
)

type UserStatus struct {
	// Custom status text
	Text string `json:"text"`
	// Presence status
	Presence Presence `json:"presence"`
}

type UserProfile struct {
	// Text content on user's profile
	Content    string      `json:"content"`
	Background *AutumnFile `json:"background"`
}

type UserFlags int

const (
	UserFlagsSuspended UserFlags = 1 << (0 + iota)
	UserFlagsDeleted
	UserFlagsBanned
	UserFlagsSpam
)

type UserBot struct {
	// ID of the owner of this bot
	Owner ULID `json:"owner"`
}

type User struct {
	// Unique ID
	ID ULID `json:"_id"`
	// Username
	Username string `json:"username"`
	// Discriminator
	Discriminator string `json:"discriminator"`
	// Display name
	DisplayName string      `json:"display_name"`
	Avatar      *AutumnFile `json:"avatar"`
	// Relationships with other users
	Relations []*UserRelation `json:"relations"`
	// Bitfield of user badges
	Badges UserBadges `json:"badges"`
	// User's active status
	Status *UserStatus `json:"status"`
	// User's profile
	Profile *UserProfile `json:"profile"`
	// Enum of user flags
	Flags UserFlags `json:"flags"`
	// Whether this user is privileged
	Privileged bool `json:"privileged"`
	// Bot information for if the user is a bot
	Bot *UserBot `json:"bot"`
	// User's relationship with another user (or themselves)
	Relationship RelationshipStatus `json:"relationship"`
	// Whether this user is currently online
	Online bool `json:"online"`
}

type OptimizedUserFlags int

const (
	OptimizedUserFlagsSuspended OptimizedUserFlags = 1 << (0 + iota)
	OptimizedUserFlagsDeleted
	OptimizedUserFlagsBanned
	OptimizedUserFlagsSpam
	OptimizedUserFlagsPrivileged
	OptimizedUserFlagsOnline
	OptimizedUserFlagsDeveloper
	OptimizedUserFlagsTranslator
	OptimizedUserFlagsSupporter
	OptimizedUserFlagsResponsibleDisclosure
	OptimizedUserFlagsFounder
	OptimizedUserFlagsPlatformModeration
	OptimizedUserFlagsActiveSupporter
	OptimizedUserFlagsPaw
	OptimizedUserFlagsEarlyAdopter
	OptimizedUserFlagsRelevantJokeBadge1
)

func (r *OptimizedUserFlags) updateFlags(flags UserFlags) {
	(*r) = ^(OptimizedUserFlagsSuspended | OptimizedUserFlagsDeleted | OptimizedUserFlagsBanned | OptimizedUserFlagsSpam)
	if (flags & UserFlagsSuspended) != 0 {
		(*r) |= OptimizedUserFlagsSuspended
	}
	if (flags & UserFlagsDeleted) != 0 {
		(*r) |= OptimizedUserFlagsDeleted
	}
	if (flags & UserFlagsBanned) != 0 {
		(*r) |= OptimizedUserFlagsBanned
	}
	if (flags & UserFlagsSpam) != 0 {
		(*r) |= OptimizedUserFlagsSpam
	}
}

func (r *OptimizedUserFlags) updateBadges(badges UserBadges) {
	(*r) = ^(OptimizedUserFlagsDeveloper | OptimizedUserFlagsTranslator | OptimizedUserFlagsSupporter | OptimizedUserFlagsResponsibleDisclosure | OptimizedUserFlagsFounder | OptimizedUserFlagsPlatformModeration | OptimizedUserFlagsActiveSupporter | OptimizedUserFlagsPaw | OptimizedUserFlagsEarlyAdopter | OptimizedUserFlagsRelevantJokeBadge1)
	if (badges & UserBadgesDeveloper) != 0 {
		(*r) |= OptimizedUserFlagsDeveloper
	}
	if (badges & UserBadgesTranslator) != 0 {
		(*r) |= OptimizedUserFlagsTranslator
	}
	if (badges & UserBadgesSupporter) != 0 {
		(*r) |= OptimizedUserFlagsSupporter
	}
	if (badges & UserBadgesResponsibleDisclosure) != 0 {
		(*r) |= OptimizedUserFlagsResponsibleDisclosure
	}
	if (badges & UserBadgesFounder) != 0 {
		(*r) |= OptimizedUserFlagsFounder
	}
	if (badges & UserBadgesPlatformModeration) != 0 {
		(*r) |= OptimizedUserFlagsPlatformModeration
	}
	if (badges & UserBadgesActiveSupporter) != 0 {
		(*r) |= OptimizedUserFlagsActiveSupporter
	}
	if (badges & UserBadgesPaw) != 0 {
		(*r) |= OptimizedUserFlagsPaw
	}
	if (badges & UserBadgesEarlyAdopter) != 0 {
		(*r) |= OptimizedUserFlagsEarlyAdopter
	}
	if (badges & UserBadgesRelevantJokeBadge1) != 0 {
		(*r) |= OptimizedUserFlagsRelevantJokeBadge1
	}
}
func NewOptimizedUserFlags(badges UserBadges, flags UserFlags, privileged, online bool) OptimizedUserFlags {
	r := OptimizedUserFlags(0)
	if (flags & UserFlagsSuspended) != 0 {
		r |= OptimizedUserFlagsSuspended
	}
	if (flags & UserFlagsDeleted) != 0 {
		r |= OptimizedUserFlagsDeleted
	}
	if (flags & UserFlagsBanned) != 0 {
		r |= OptimizedUserFlagsBanned
	}
	if (flags & UserFlagsSpam) != 0 {
		r |= OptimizedUserFlagsSpam
	}
	if privileged {
		r |= OptimizedUserFlagsPrivileged
	}
	if online {
		r |= OptimizedUserFlagsOnline
	}
	if (badges & UserBadgesDeveloper) != 0 {
		r |= OptimizedUserFlagsDeveloper
	}
	if (badges & UserBadgesTranslator) != 0 {
		r |= OptimizedUserFlagsTranslator
	}
	if (badges & UserBadgesSupporter) != 0 {
		r |= OptimizedUserFlagsSupporter
	}
	if (badges & UserBadgesResponsibleDisclosure) != 0 {
		r |= OptimizedUserFlagsResponsibleDisclosure
	}
	if (badges & UserBadgesFounder) != 0 {
		r |= OptimizedUserFlagsFounder
	}
	if (badges & UserBadgesPlatformModeration) != 0 {
		r |= OptimizedUserFlagsPlatformModeration
	}
	if (badges & UserBadgesActiveSupporter) != 0 {
		r |= OptimizedUserFlagsActiveSupporter
	}
	if (badges & UserBadgesPaw) != 0 {
		r |= OptimizedUserFlagsPaw
	}
	if (badges & UserBadgesEarlyAdopter) != 0 {
		r |= OptimizedUserFlagsEarlyAdopter
	}
	if (badges & UserBadgesRelevantJokeBadge1) != 0 {
		r |= OptimizedUserFlagsRelevantJokeBadge1
	}
	return r
}

type OptimizedPresence int

const (
	OptimizedPresenceUnknown OptimizedPresence = iota
	OptimizedPresenceOnline
	OptimizedPresenceIdle
	OptimizedPresenceFocus
	OptimizedPresenceBusy
	OptimizedPresenceInvisible
)

type OptimizedUserStatus struct {
	Text     string
	Presence OptimizedPresence
}

func (o Presence) ToOptimized() OptimizedPresence {
	switch o {
	case PresenceOnline:
		return OptimizedPresenceOnline
	case PresenceIdle:
		return OptimizedPresenceIdle
	case PresenceFocus:
		return OptimizedPresenceFocus
	case PresenceBusy:
		return OptimizedPresenceBusy
	case PresenceInvisible:
		return OptimizedPresenceInvisible
	}
	return OptimizedPresenceUnknown
}

func (o *UserStatus) ToOptimized() *OptimizedUserStatus {
	return &OptimizedUserStatus{Text: o.Text, Presence: o.Presence.ToOptimized()}
}

type OptimizedRelationshipStatus int

const (
	OptimizedRelationshipStatusUnknown OptimizedRelationshipStatus = iota
	OptimizedRelationshipStatusNone
	OptimizedRelationshipStatusUser
	OptimizedRelationshipStatusFriend
	OptimizedRelationshipStatusOutgoing
	OptimizedRelationshipStatusIncoming
	OptimizedRelationshipStatusBlocked
	OptimizedRelationshipStatusBlockedOther
)

func (s RelationshipStatus) ToOptimized() OptimizedRelationshipStatus {
	switch s {
	case RelationshipStatusNone:
		return OptimizedRelationshipStatusNone
	case RelationshipStatusUser:
		return OptimizedRelationshipStatusUser
	case RelationshipStatusFriend:
		return OptimizedRelationshipStatusFriend
	case RelationshipStatusOutgoing:
		return OptimizedRelationshipStatusOutgoing
	case RelationshipStatusIncoming:
		return OptimizedRelationshipStatusIncoming
	case RelationshipStatusBlocked:
		return OptimizedRelationshipStatusBlocked
	case RelationshipStatusBlockedOther:
		return OptimizedRelationshipStatusBlockedOther
	}
	return OptimizedRelationshipStatusUnknown
}

type OptimizedUser struct {
	ID            ULID
	Username      string
	Discriminator string
	DisplayName   string
	Avatar        *OptimizedAutumnFile
	Relations     []*UserRelation
	Status        *OptimizedUserStatus
	Profile       *UserProfile
	Bot           *UserBot
	Relationship  OptimizedRelationshipStatus
	Flags         OptimizedUserFlags
}

func (o OptimizedUser) GetKey() ULID {
	return o.ID
}

func (u *User) ToOptimized() *OptimizedUser {
	var status *OptimizedUserStatus
	if u.Status != nil {
		status = u.Status.ToOptimized()
	}
	o := &OptimizedUser{
		ID:            u.ID,
		Username:      u.Username,
		Discriminator: u.Discriminator,
		DisplayName:   u.DisplayName,
		Relations:     u.Relations,
		Status:        status,
		Profile:       u.Profile,
		Bot:           u.Bot,
		Relationship:  u.Relationship.ToOptimized(),
		Flags:         NewOptimizedUserFlags(u.Badges, u.Flags, u.Privileged, u.Online),
	}
	if u.Avatar != nil {
		o.Avatar = u.Avatar.ToOptimized()
	}
	return o
}

type PartialUser struct {
	// Unique ID
	ID ULID `json:"_id"`
	// Username
	Username *string `json:"username"`
	// Discriminator
	Discriminator *string `json:"discriminator"`
	// Display name
	DisplayName *string     `json:"display_name"`
	Avatar      *AutumnFile `json:"avatar"`
	// Relationships with other users
	Relations *[]*UserRelation `json:"relations"`
	// Bitfield of user badges
	Badges *UserBadges `json:"badges"`
	// User's active status
	Status *UserStatus `json:"status"`
	// User's profile
	Profile *UserProfile `json:"profile"`
	// Enum of user flags
	Flags *UserFlags `json:"flags"`
	// Bot information for if the user is a bot
	Bot *UserBot `json:"bot"`
	// User's relationship with another user (or themselves)
	Relationship *RelationshipStatus `json:"relationship"`
	// Whether this user is currently online
	Online *bool `json:"online"`
}

type ChannelType string

const (
	ChannelTypeSavedMessages ChannelType = "SavedMessages"
	ChannelTypeDirectMessage ChannelType = "DirectMessage"
	ChannelTypeGroup         ChannelType = "Group"
	ChannelTypeTextChannel   ChannelType = "TextChannel"
	ChannelTypeVoiceChannel  ChannelType = "VoiceChannel"
)

type Permissions int64

const (
	PermissionManageChannel Permissions = 1 << iota
	PermissionManageServer
	PermissionManagePermissions
	PermissionManageRoles
	PermissionManageCustomisation
	PermissionKickMembers Permissions = 1 << (6 + iota)
	PermissionBanMembers
	PermissionTimeoutMembers
	PermissionAssignRoles
	PermissionChangeNickname
	PermissionManageNicknames
	PermissionChangeAvatar
	PermissionRemoveAvatars
	PermissionViewChannel Permissions = 1 << (20 + iota)
	PermissionReadMessageHistory
	PermissionSendMessages
	PermissionManageMessages
	PermissionManageWebhooks
	PermissionInviteOthers
	PermissionSendEmbeds
	PermissionUploadFiles
	PermissionMasquerade
	PermissionReact
	PermissionConnect
	PermissionSpeak
	PermissionVideo
	PermissionMuteMembers
	PermissionDeafenMembers
	PermissionMoveMembers
)

type PermissionOverride struct {
	// Allow bit flags
	Allow Permissions `json:"a"`
	// Disallow bit flags
	Disallow Permissions `json:"d"`
}

type Channel struct {
	Type ChannelType `json:"channel_type"`
	// Unique ID
	ID ULID `json:"_id"`
	// ID of the server this channel belongs to
	Server ULID `json:"server"`
	// Display name of the channel
	Name string `json:"name"`
	// Whether this direct message channel is currently open on both sides
	Active bool `json:"active"`
	// User ID of the owner of the group
	Owner ULID `json:"owner"`
	// Channel description
	Description string      `json:"description"`
	Icon        *AutumnFile `json:"icon"`
	// 2-tuple of user ids participating in direct message / Array of user ids participating in channel
	Recipients []ULID `json:"recipients"`
	// ID of the last message sent in this channel
	LastMessageID ULID `json:"last_message_id"`
	// Permissions assigned to members of this group (does not apply to the owner of the group)
	Permissions Permissions `json:"permissions"`
	// Representation of a single permission override as it appears on models and in the database
	DefaultPermissions *PermissionOverride `json:"default_permissions"`
	// Permissions assigned based on role to this channel
	RolePermissions map[ULID]PermissionOverride `json:"role_permissions"`
	// ID of the user this channel belongs to
	User ULID `json:"user"`
	// Whether this group is marked as not safe for work
	NSFW bool `json:"nsfw"`
}

func (c Channel) GetKey() ULID {
	return c.ID
}

type OptimizedChannelType int

const (
	OptimizedChannelTypeUnknown OptimizedChannelType = iota
	OptimizedChannelTypeSavedMessages
	OptimizedChannelTypeDirectMessage
	OptimizedChannelTypeGroup
	OptimizedChannelTypeTextChannel
	OptimizedChannelTypeVoiceChannel
)

func (ct ChannelType) ToOptimized() OptimizedChannelType {
	switch ct {
	case ChannelTypeSavedMessages:
		return OptimizedChannelTypeSavedMessages
	case ChannelTypeDirectMessage:
		return OptimizedChannelTypeDirectMessage
	case ChannelTypeGroup:
		return OptimizedChannelTypeGroup
	case ChannelTypeTextChannel:
		return OptimizedChannelTypeTextChannel
	case ChannelTypeVoiceChannel:
		return OptimizedChannelTypeVoiceChannel
	default:
		return OptimizedChannelTypeUnknown
	}
}

type OptimizedChannelFlags int

const (
	OptimizedChannelFlagActive OptimizedChannelFlags = 1 << (0 + iota)
	OptimizedChannelFlagNSFW
)

// Same as Channel, but with flags bitfield instead of bools
type OptimizedChannel struct {
	Type OptimizedChannelType
	// Unique ID
	ID ULID
	// ID of the server this channel belongs to
	Server ULID
	// Display name of the channel
	Name  string
	Flags OptimizedChannelFlags
	// User ID of the owner of the group
	Owner ULID
	// Channel description
	Description string
	Icon        *OptimizedAutumnFile
	// 2-tuple of user ids participating in direct message / Array of user ids participating in channel
	Recipients []ULID
	// ID of the last message sent in this channel
	LastMessageID ULID
	// Permissions assigned to members of this group (does not apply to the owner of the group)
	Permissions Permissions
	// Representation of a single permission override as it appears on models and in the database
	DefaultPermissions *PermissionOverride
	// Permissions assigned based on role to this channel
	RolePermissions map[ULID]PermissionOverride
	// ID of the user this channel belongs to
	User ULID
}

func (c OptimizedChannel) GetKey() ULID {
	return c.ID
}

func (c *Channel) ToOptimized() *OptimizedChannel {
	oc := &OptimizedChannel{
		Type:               c.Type.ToOptimized(),
		Server:             c.Server,
		Name:               c.Name,
		Owner:              c.Owner,
		Description:        c.Description,
		Recipients:         c.Recipients,
		LastMessageID:      c.LastMessageID,
		Permissions:        c.Permissions,
		DefaultPermissions: c.DefaultPermissions,
		RolePermissions:    c.RolePermissions,
		User:               c.User,
	}
	if c.Icon != nil {
		oc.Icon = c.Icon.ToOptimized()
	}
	if c.Active {
		oc.Flags |= OptimizedChannelFlagActive
	}
	if c.NSFW {
		oc.Flags |= OptimizedChannelFlagNSFW
	}
	return oc
}

type PartialChannel struct {
	Type ChannelType `json:"channel_type"`
	// Unique ID
	ID ULID `json:"_id"`
	// ID of the server this channel belongs to
	Server ULID `json:"server"`
	// Display name of the channel
	Name string `json:"name"`
	// Whether this direct message channel is currently open on both sides
	Active *bool `json:"active"`
	// User ID of the owner of the group
	Owner ULID `json:"owner"`
	// Channel description
	Description *string     `json:"description"`
	Icon        *AutumnFile `json:"icon"`
	// 2-tuple of user ids participating in direct message / Array of user ids participating in channel
	Recipients []ULID `json:"recipients"`
	// ID of the last message sent in this channel
	LastMessageID ULID `json:"last_message_id"`
	// Permissions assigned to members of this group (does not apply to the owner of the group)
	Permissions *Permissions `json:"permissions"`
	// Representation of a single permission override as it appears on models and in the database
	DefaultPermissions *PermissionOverride `json:"default_permissions"`
	// Permissions assigned based on role to this channel
	RolePermissions *map[ULID]PermissionOverride `json:"role_permissions"`
	// ID of the user this channel belongs to
	User *ULID `json:"user"`
	// Whether this group is marked as not safe for work
	NSFW *bool `json:"nsfw"`
}

type BotFlags int

const (
	BotFlagsVerified BotFlags = 1 << (0 + iota)
	BotFlagsOfficial
)

type Bot struct {
	// Bot ID. This equals the associated bot user's ID.
	ID ULID `json:"_id"`
	// User ID of the bot owner
	Owner ULID `json:"owner"`
	// Token used to authenticate requests for this bot
	Token string `json:"token"`
	// Whether the bot is public (may be invited by anyone)
	Public bool `json:"public"`
	// Whether to enable analytics
	Analytics bool `json:"analytics"`
	// Whether this bot should be publicly discoverable
	Discoverable bool `json:"discoverable"`
	// Reserved; URL for handling interactions
	InteractionsURL string `json:"interactions_url"`
	// URL for terms of service
	TermsOfServiceURL string `json:"terms_of_service_url"`
	// URL for privacy policy
	PrivacyPolicyURL string `json:"privacy_policy_url"`
	// Enum of bot flags
	Flags BotFlags `json:"flags"`
}

type PublicBot struct {
	// Bot ID
	ID ULID `json:"_id"`
	// Bot username
	Username string `json:"username"`
	// Profile Avatar
	Avatar string `json:"avatar"`
	// Profile Description
	Description string `json:"description"`
}

type InviteType string

const (
	InviteTypeServer InviteType = "Server"
	InviteTypeGroup  InviteType = "Group"
)

type Invite struct {
	Type InviteType `json:"type"`
	// Invite code
	ID string `json:"_id"`
	// ID of the server this invite points to
	Server ULID `json:"server"`
	// ID of user who created this invite
	Creator ULID `json:"creator"`
	// ID of the server channel this invite points to / ID of the group channel this invite points to
	Channel ULID `json:"channel"`
}

type InviteResponse struct {
	Type InviteType `json:"type"`
	// Invite code
	Code string `json:"code"`
	// ID of the server
	ServerID ULID `json:"server_id"`
	// Name of the server
	ServerName   string      `json:"server_name"`
	ServerIcon   *AutumnFile `json:"server_icon"`
	ServerBanner *AutumnFile `json:"server_banner"`
	// Enum of server flags
	ServerFlags ServerFlags `json:"server_flags"`
	// ID of server channel
	ChannelID ULID `json:"channel_id"`
	// Name of server channel
	ChannelName string `json:"channel_name"`
	// Description of server channel
	ChannelDescription string `json:"channel_description"`
	// Name of user who created the invite
	UserName   string      `json:"user_name"`
	UserAvatar *AutumnFile `json:"user_avatar"`
	// Number of members in this server
	MemberCount int `json:"member_count"`
}

type MessageWebhook struct {
	Name   string `json:"name"`
	Avatar string `json:"avatar"`
}

type SystemEventMessageType string

const (
	SystemEventMessageTypeText                      SystemEventMessageType = "text"
	SystemEventMessageTypeUserAdded                 SystemEventMessageType = "user_added"
	SystemEventMessageTypeUserRemove                SystemEventMessageType = "user_remove"
	SystemEventMessageTypeUserJoined                SystemEventMessageType = "user_joined"
	SystemEventMessageTypeUserLeft                  SystemEventMessageType = "user_left"
	SystemEventMessageTypeUserKicked                SystemEventMessageType = "user_kicked"
	SystemEventMessageTypeUserBanned                SystemEventMessageType = "user_banned"
	SystemEventMessageTypeChannelRenamed            SystemEventMessageType = "channel_renamed"
	SystemEventMessageTypeChannelDescriptionChanged SystemEventMessageType = "channel_description_changed"
	SystemEventMessageTypeChannelIconChanged        SystemEventMessageType = "channel_icon_changed"
	SystemEventMessageTypeChannelOwnershipChanged   SystemEventMessageType = "channel_ownership_changed"
)

type OptimizedSystemEventMessageType int

const (
	OptimizedSystemEventMessageTypeUnknown OptimizedSystemEventMessageType = iota
	OptimizedSystemEventMessageTypeText
	OptimizedSystemEventMessageTypeUserAdded
	OptimizedSystemEventMessageTypeUserRemove
	OptimizedSystemEventMessageTypeUserJoined
	OptimizedSystemEventMessageTypeUserLeft
	OptimizedSystemEventMessageTypeUserKicked
	OptimizedSystemEventMessageTypeUserBanned
	OptimizedSystemEventMessageTypeChannelRenamed
	OptimizedSystemEventMessageTypeChannelDescriptionChanged
	OptimizedSystemEventMessageTypeChannelIconChanged
	OptimizedSystemEventMessageTypeChannelOwnershipChanged
)

func (s SystemEventMessageType) ToOptimized() OptimizedSystemEventMessageType {
	switch s {
	case SystemEventMessageTypeText:
		return OptimizedSystemEventMessageTypeText
	case SystemEventMessageTypeUserAdded:
		return OptimizedSystemEventMessageTypeUserAdded
	case SystemEventMessageTypeUserRemove:
		return OptimizedSystemEventMessageTypeUserRemove
	case SystemEventMessageTypeUserJoined:
		return OptimizedSystemEventMessageTypeUserJoined
	case SystemEventMessageTypeUserLeft:
		return OptimizedSystemEventMessageTypeUserLeft
	case SystemEventMessageTypeUserKicked:
		return OptimizedSystemEventMessageTypeUserKicked
	case SystemEventMessageTypeUserBanned:
		return OptimizedSystemEventMessageTypeUserBanned
	case SystemEventMessageTypeChannelRenamed:
		return OptimizedSystemEventMessageTypeChannelRenamed
	case SystemEventMessageTypeChannelDescriptionChanged:
		return OptimizedSystemEventMessageTypeChannelDescriptionChanged
	case SystemEventMessageTypeChannelIconChanged:
		return OptimizedSystemEventMessageTypeChannelIconChanged
	case SystemEventMessageTypeChannelOwnershipChanged:
		return OptimizedSystemEventMessageTypeChannelOwnershipChanged
	}
	return OptimizedSystemEventMessageTypeUnknown
}

// Representation of a system event message
type SystemEventMessage struct {
	Type    SystemEventMessageType `json:"type"`
	Content string                 `json:"content"`
	ID      ULID                   `json:"id"`
	Name    string                 `json:"name"`
	By      ULID                   `json:"by"`
	From    ULID                   `json:"from"`
	To      ULID                   `json:"to"`
}

type OptimizedSystemEventMessage struct {
	Type    OptimizedSystemEventMessageType
	Content string
	ID      ULID
	Name    string
	By      ULID
	From    ULID
	To      ULID
}

func (o *SystemEventMessage) ToOptimized() *OptimizedSystemEventMessage {
	return &OptimizedSystemEventMessage{Type: o.Type.ToOptimized(), Content: o.Content, ID: o.ID, Name: o.Name, By: o.By, From: o.From, To: o.To}
}

type EmbedSpecialType string

const (
	EmbedSpecialTypeNone       EmbedSpecialType = "None"
	EmbedSpecialTypeGIF        EmbedSpecialType = "GIF"
	EmbedSpecialTypeYouTube    EmbedSpecialType = "YouTube"
	EmbedSpecialTypeLightspeed EmbedSpecialType = "Lightspeed"
	EmbedSpecialTypeTwitch     EmbedSpecialType = "Twitch"
	EmbedSpecialTypeSpotify    EmbedSpecialType = "Spotify"
	EmbedSpecialTypeSoundcloud EmbedSpecialType = "Soundcloud"
	EmbedSpecialTypeBandcamp   EmbedSpecialType = "Bandcamp"
	EmbedSpecialTypeStreamable EmbedSpecialType = "Streamable"
)

type OptimizedEmbedSpecialType int

const (
	OptimizedEmbedSpecialTypeUnknown OptimizedEmbedSpecialType = iota
	OptimizedEmbedSpecialTypeNone
	OptimizedEmbedSpecialTypeGIF
	OptimizedEmbedSpecialTypeYouTube
	OptimizedEmbedSpecialTypeLightspeed
	OptimizedEmbedSpecialTypeTwitch
	OptimizedEmbedSpecialTypeSpotify
	OptimizedEmbedSpecialTypeSoundcloud
	OptimizedEmbedSpecialTypeBandcamp
	OptimizedEmbedSpecialTypeStreamable
)

func (s EmbedSpecialType) ToOptimized() OptimizedEmbedSpecialType {
	switch s {
	case EmbedSpecialTypeNone:
		return OptimizedEmbedSpecialTypeNone
	case EmbedSpecialTypeGIF:
		return OptimizedEmbedSpecialTypeGIF
	case EmbedSpecialTypeYouTube:
		return OptimizedEmbedSpecialTypeYouTube
	case EmbedSpecialTypeLightspeed:
		return OptimizedEmbedSpecialTypeLightspeed
	case EmbedSpecialTypeTwitch:
		return OptimizedEmbedSpecialTypeTwitch
	case EmbedSpecialTypeSpotify:
		return OptimizedEmbedSpecialTypeSpotify
	case EmbedSpecialTypeSoundcloud:
		return OptimizedEmbedSpecialTypeSoundcloud
	case EmbedSpecialTypeBandcamp:
		return OptimizedEmbedSpecialTypeBandcamp
	case EmbedSpecialTypeStreamable:
		return OptimizedEmbedSpecialTypeStreamable
	}
	return OptimizedEmbedSpecialTypeUnknown
}

type EmbedSpecial struct {
	Type EmbedSpecialType `json:"type"`
	ID   string           `json:"id"`
	// Type of remote Lightspeed.tv content / Type of remote Twitch content / Type of remote Bandcamp content
	ContentType string `json:"content_type"`
	Timestamp   string `json:"timestamp"`
}

type OptimizedEmbedSpecial struct {
	Type        OptimizedEmbedSpecialType
	ID          string
	ContentType string
	Timestamp   string
}

func (o *EmbedSpecial) ToOptimized() *OptimizedEmbedSpecial {
	return &OptimizedEmbedSpecial{Type: o.Type.ToOptimized(), ID: o.ID, ContentType: o.ContentType, Timestamp: o.Timestamp}
}

type EmbedImageSize string

const (
	EmbedImageSizeLarge   EmbedImageSize = "Large"
	EmbedImageSizePreview EmbedImageSize = "Preview"
)

type EmbedImage struct {
	URL    string         `json:"url"`
	Width  int            `json:"width"`
	Height int            `json:"height"`
	Size   EmbedImageSize `json:"size"`
}

type OptimizedEmbedImageSize int

const (
	OptimizedEmbedImageSizeUnknown OptimizedEmbedImageSize = iota
	OptimizedEmbedImageSizeLarge
	OptimizedEmbedImageSizePreview
)

func (s EmbedImageSize) ToOptimized() OptimizedEmbedImageSize {
	switch s {
	case EmbedImageSizeLarge:
		return OptimizedEmbedImageSizeLarge
	case EmbedImageSizePreview:
		return OptimizedEmbedImageSizePreview
	}
	return OptimizedEmbedImageSizeUnknown
}

type OptimizedEmbedImage struct {
	URL    string
	Width  int
	Height int
	Size   OptimizedEmbedImageSize
}

func (o *EmbedImage) ToOptimized() *OptimizedEmbedImage {
	return &OptimizedEmbedImage{URL: o.URL, Width: o.Width, Height: o.Height, Size: o.Size.ToOptimized()}
}

type EmbedVideo struct {
	URL    string `json:"url"`
	Width  int    `json:"width"`
	Height int    `json:"height"`
}

type EmbedType string

const (
	EmbedTypeWebsite EmbedType = "Website"
	EmbedTypeImage   EmbedType = "Image"
	EmbedTypeVideo   EmbedType = "Video"
	EmbedTypeText    EmbedType = "Text"
	EmbedTypeNone    EmbedType = "None"
)

type Embed struct {
	Type EmbedType `json:"type"`
	// Direct URL to web page / URL to the original image / URL to the original video / URL for title
	URL string `json:"url"`
	// Original direct URL
	OriginalURL string `json:"original_url"`
	// Information about special remote content
	Special *EmbedSpecial `json:"special"`
	// Title of website / Title of text embed
	Title string `json:"title"`
	// Description of website / Description of text embed
	Description string `json:"description"`
	// Image
	Image *EmbedImage `json:"image"`
	// Video
	Video *EmbedVideo `json:"video"`
	// Site name
	SiteName string `json:"site_name"`
	// URL to site icon / URL to icon
	IconURL string      `json:"icon_url"`
	Media   *AutumnFile `json:"media"`
	// CSS Colour
	Colour string `json:"colour"`
	// Width of the image / Width of the video
	Width int `json:"width"`
	// Height of the image / Height of the video
	Height int `json:"height"`
	// Image positioning and size
	Size EmbedImageSize `json:"size"`
}

type OptimizedEmbedType int

const (
	OptimizedEmbedTypeUnknown OptimizedEmbedType = iota
	OptimizedEmbedTypeWebsite
	OptimizedEmbedTypeImage
	OptimizedEmbedTypeVideo
	OptimizedEmbedTypeText
	OptimizedEmbedTypeNone
)

func (s EmbedType) ToOptimized() OptimizedEmbedType {
	switch s {
	case EmbedTypeWebsite:
		return OptimizedEmbedTypeWebsite
	case EmbedTypeImage:
		return OptimizedEmbedTypeImage
	case EmbedTypeVideo:
		return OptimizedEmbedTypeVideo
	case EmbedTypeText:
		return OptimizedEmbedTypeText
	case EmbedTypeNone:
		return OptimizedEmbedTypeNone
	}
	return OptimizedEmbedTypeUnknown
}

type OptimizedEmbed struct {
	Type        OptimizedEmbedType
	URL         string
	OriginalURL string
	Special     *OptimizedEmbedSpecial
	Title       string
	Description string
	Image       *OptimizedEmbedImage
	Video       *EmbedVideo
	SiteName    string
	IconURL     string
	Media       *OptimizedAutumnFile
	Colour      string
	Width       int
	Height      int
	Size        OptimizedEmbedImageSize
}

func (o *Embed) ToOptimized() *OptimizedEmbed {
	var special *OptimizedEmbedSpecial
	if o.Special != nil {
		special = o.Special.ToOptimized()
	}
	var image *OptimizedEmbedImage
	if o.Image != nil {
		image = o.Image.ToOptimized()
	}
	var media *OptimizedAutumnFile
	if o.Media != nil {
		media = o.Media.ToOptimized()
	}
	return &OptimizedEmbed{
		Type:        o.Type.ToOptimized(),
		URL:         o.URL,
		OriginalURL: o.OriginalURL,
		Special:     special,
		Title:       o.Title,
		Description: o.Description,
		Image:       image,
		Video:       o.Video,
		SiteName:    o.SiteName,
		IconURL:     o.IconURL,
		Media:       media,
		Colour:      o.Colour,
		Width:       o.Width,
		Height:      o.Height,
		Size:        o.Size.ToOptimized(),
	}
}

// Information to guide interactions on this message
type MessageInteractions struct {
	// Reactions which should always appear and be distinct
	Reactions []string `json:"reactions,omitempty"`
	// Whether reactions should be restricted to the given list
	// Can only be set to true if reactions list is of at least length 1
	RestrictReactions bool `json:"restrict_reactions"`
}

// Name and / or avatar override information
type Masquerade struct {
	// Replace the display name shown on this message
	Name string `json:"name,omitempty"`
	// Replace the avatar shown on this message (URL to image file)
	Avatar string `json:"avatar,omitempty"`
	// Replace the display role colour shown on this message
	// Must have ManageRole permission to use
	Colour string `json:"colour,omitempty"`
}

type Message struct {
	// Unique ID
	ID ULID `json:"_id"`
	// Unique value generated by client sending this message
	Nonce *string `json:"nonce"`
	// ID of the channel this message was sent in
	Channel ULID `json:"channel"`
	// ID of the user or webhook that sent this message
	Author ULID `json:"author"`
	// Information about the webhook bundled with Message
	Webhook *MessageWebhook `json:"webhook"`
	// Message content
	Content string              `json:"content"`
	System  *SystemEventMessage `json:"system"`
	// Array of attachments
	Attachments []*AutumnFile `json:"attachments"`
	// ISO8601 formatted timestamp
	Edited *time.Time `json:"edited"`
	// Attached embeds to this message
	Embeds []*Embed `json:"embeds"`
	// Array of user ids mentioned in this message
	Mentions []ULID `json:"mentions"`
	// Array of message ids this message is replying to
	Replies []ULID `json:"replies"`
	// Hashmap of emoji IDs to array of user IDs
	Reactions    map[string][]ULID    `json:"reactions"`
	Interactions *MessageInteractions `json:"interactions"`
	Masquerade   *Masquerade          `json:"masquerade"`
}

func (o Message) GetKey() ULID {
	return o.ID
}

type OptimizedMessage struct {
	ID           ULID
	Nonce        *string
	Channel      ULID
	Author       ULID
	Webhook      *MessageWebhook
	Content      string
	System       *OptimizedSystemEventMessage
	Attachments  []*OptimizedAutumnFile
	Edited       *time.Time
	Embeds       []*OptimizedEmbed
	Mentions     []ULID
	Replies      []ULID
	Reactions    map[string][]ULID
	Interactions *MessageInteractions
	Masquerade   *Masquerade
}

func (o OptimizedMessage) GetKey() ULID {
	return o.ID
}

func (o *Message) ToOptimized() *OptimizedMessage {
	var embeds []*OptimizedEmbed
	for _, e := range o.Embeds {
		embeds = append(embeds, e.ToOptimized())
	}
	var attachments []*OptimizedAutumnFile
	for _, a := range o.Attachments {
		attachments = append(attachments, a.ToOptimized())
	}
	var system *OptimizedSystemEventMessage
	if o.System != nil {
		system = o.System.ToOptimized()
	}
	return &OptimizedMessage{
		ID: o.ID, Nonce: o.Nonce, Channel: o.Channel, Author: o.Author, Webhook: o.Webhook,
		Content: o.Content, System: system, Attachments: attachments,
		Edited: o.Edited, Embeds: embeds, Mentions: o.Mentions, Replies: o.Replies,
		Reactions: o.Reactions, Interactions: o.Interactions, Masquerade: o.Masquerade,
	}
}

// Composite primary key consisting of server and user id
type MemberID struct {
	Server ULID `json:"server"`
	User   ULID `json:"user"`
}

type Member struct {
	ID       MemberID  `json:"_id"`
	JoinedAt time.Time `json:"joined_at"`
	// Member's nickname
	Nickname string      `json:"nickname"`
	Avatar   *AutumnFile `json:"avatar"`
	// Member's roles
	Roles   []ULID     `json:"roles"`
	Timeout *time.Time `json:"timeout"`
}

func (o Member) GetKey() ULID {
	return o.ID.User
}

type PartialMember struct {
	ID MemberID `json:"_id"`
	// Member's nickname
	Nickname *string     `json:"nickname"`
	Avatar   *AutumnFile `json:"avatar"`
	// Member's roles
	Roles *[]ULID `json:"roles"`
	// ISO8601 formatted timestamp
	Timeout *time.Time `json:"timeout"`
}

type Webhook struct {
	// Webhook ID
	ID ULID `json:"id"`
	// The name of the webhook
	Name   string      `json:"name"`
	Avatar *AutumnFile `json:"avatar"`
	// The channel this webhook belongs to
	ChannelID ULID `json:"channel_id"`
	// The private token for the webhook
	Token string `json:"token"`
}

type Category struct {
	// Unique ID for this category
	ID ULID `json:"id"`
	// Title for this category
	Title string `json:"title"`
	// Channels in this category
	Channels []ULID `json:"channels"`
}

type SystemMessages struct {
	// ID of channel to send user join messages in
	UserJoined ULID `json:"user_joined"`
	// ID of channel to send user left messages in
	UserLeft ULID `json:"user_left"`
	// ID of channel to send user kicked messages in
	UserKicked ULID `json:"user_kicked"`
	// ID of channel to send user banned messages in
	UserBanned ULID `json:"user_banned"`
}

type Role struct {
	// Role name
	Name string `json:"name"`
	// Representation of a single permission override as it appears on models and in the database
	Permissions PermissionOverride `json:"permissions"`
	// Colour used for this role
	// This can be any valid CSS colour
	Colour string `json:"colour"`
	// Whether this role should be shown separately on the member sidebar
	Hoist bool `json:"hoist"`
	// Default: `0`
	// Ranking of this role
	Rank int `json:"rank"`
}

type OptimizedRoleFlags int

const (
	OptimizedRoleFlagsHoist OptimizedRoleFlags = 1 << (0 + iota)
)

type OptimizedRole struct {
	// Unique ID
	ID ULID
	// Role name
	Name string
	// Representation of a single permission override as it appears on models and in the database
	Permissions PermissionOverride
	// Colour used for this role
	// This can be any valid CSS colour
	Colour string
	Flags  OptimizedRoleFlags
	// Default: `0`
	// Ranking of this role
	Rank int
}

func (r *Role) ToOptimized(id ULID) *OptimizedRole {
	o := &OptimizedRole{
		ID:          id,
		Name:        r.Name,
		Permissions: r.Permissions,
		Colour:      r.Colour,
		Rank:        r.Rank,
	}
	if r.Hoist {
		o.Flags |= OptimizedRoleFlagsHoist
	}
	return o
}

func (o OptimizedRole) GetKey() ULID {
	return o.ID
}

type PartialRole struct {
	// Role name
	Name *string `json:"name"`
	// Representation of a single permission override as it appears on models and in the database
	Permissions *PermissionOverride `json:"permissions"`
	// Colour used for this role
	// This can be any valid CSS colour
	Colour *string `json:"colour"`
	// Whether this role should be shown separately on the member sidebar
	Hoist *bool `json:"hoist"`
	// Default: `0`
	// Ranking of this role
	Rank *int `json:"rank"`
}

type ServerFlags int

const (
	ServerFlagsVerified ServerFlags = 1 << (0 + iota)
	ServerFlagsOfficial
)

type Server struct {
	// Unique ID
	ID ULID `json:"_id"`
	// User ID of the owner
	Owner ULID `json:"owner"`
	// Name of the server
	Name string `json:"name"`
	// Description for the server
	Description string `json:"description"`
	// Channels within this server
	Channels []ULID `json:"channels"`
	// Categories for this server
	Categories []*Category `json:"categories"`
	// System message channel assignments
	SystemMessages *SystemMessages `json:"system_messages"`
	// Roles for this server
	Roles map[ULID]*Role `json:"roles"`
	// Default set of server and channel permissions
	DefaultPermissions Permissions `json:"default_permissions"`
	Icon               *AutumnFile `json:"icon"`
	Banner             *AutumnFile `json:"banner"`
	// Bitfield of server flags
	Flags ServerFlags `json:"flags"`
	// Whether this server is flagged as not safe for work
	NSFW bool `json:"nsfw"`
	// Whether to enable analytics
	Analytics bool `json:"analytics"`
	// Whether this server should be publicly discoverable
	Discoverable bool `json:"discoverable"`
}

type OptimizedServerFlags int

const (
	OptimizedServerFlagsVerified OptimizedServerFlags = 1 << (0 + iota)
	OptimizedServerFlagsOfficial
	OptimizedServerFlagsNSFW
	OptimizedServerFlagsAnalytics
	OptimizedServerFlagsDiscoverable
)

func (sf ServerFlags) ToOptimized() (r OptimizedServerFlags) {
	if (sf & ServerFlagsVerified) != 0 {
		r |= OptimizedServerFlagsVerified
	}
	if (sf & ServerFlagsOfficial) != 0 {
		r |= OptimizedServerFlagsOfficial
	}
	return
}

type OptimizedServer struct {
	// Unique ID
	ID ULID
	// User ID of the owner
	Owner ULID
	// Name of the server
	Name string
	// Description for the server
	Description string
	// Channels within this server
	Channels []ULID
	// Categories for this server
	Categories []*Category
	// System message channel assignments
	SystemMessages *SystemMessages
	// Default set of server and channel permissions
	DefaultPermissions Permissions
	Icon               *OptimizedAutumnFile
	Banner             *OptimizedAutumnFile
	// Bitfield of server flags
	Flags OptimizedServerFlags
}

func (o OptimizedServer) GetKey() ULID {
	return o.ID
}

func (o *Server) ToOptimized() *OptimizedServer {
	r := &OptimizedServer{
		ID:                 o.ID,
		Owner:              o.Owner,
		Name:               o.Name,
		Description:        o.Description,
		Channels:           o.Channels,
		Categories:         o.Categories,
		SystemMessages:     o.SystemMessages,
		DefaultPermissions: o.DefaultPermissions,
		Flags:              o.Flags.ToOptimized(),
	}
	if o.Icon != nil {
		r.Icon = o.Icon.ToOptimized()
	}
	if o.Banner != nil {
		r.Banner = o.Banner.ToOptimized()
	}
	if o.NSFW {
		r.Flags |= OptimizedServerFlagsNSFW
	}
	if o.Analytics {
		r.Flags |= OptimizedServerFlagsAnalytics
	}
	if o.Discoverable {
		r.Flags |= OptimizedServerFlagsDiscoverable
	}
	return r
}

type PartialServer struct {
	// Unique ID
	ID ULID `json:"_id"`
	// User ID of the owner
	Owner string `json:"owner"`
	// Name of the server
	Name *string `json:"name"`
	// Description for the server
	Description *string `json:"description"`
	// Channels within this server
	Channels *[]ULID `json:"channels"`
	// Categories for this server
	Categories *[]*Category `json:"categories"`
	// System message channel assignments
	SystemMessages *SystemMessages `json:"system_messages"`
	// Roles for this server
	Roles *map[ULID]*Role `json:"roles"`
	// Default set of server and channel permissions
	DefaultPermissions *Permissions `json:"default_permissions"`
	Icon               *AutumnFile  `json:"icon"`
	Banner             *AutumnFile  `json:"banner"`
	// Bitfield of server flags
	Flags *ServerFlags `json:"flags"`
	// Whether this server is flagged as not safe for work
	NSFW *bool `json:"nsfw"`
	// Whether to enable analytics
	Analytics *bool `json:"analytics"`
	// Whether this server should be publicly discoverable
	Discoverable *bool `json:"discoverable"`
}

type CustomEmojiParentType string

const (
	CustomEmojiParentTypeServer   CustomEmojiParentType = "Server"
	CustomEmojiParentTypeDetached CustomEmojiParentType = "Detached"
)

type CustomEmojiParent struct {
	Type CustomEmojiParentType `json:"type"`
	ID   ULID                  `json:"id"`
}

type CustomEmoji struct {
	// Unique ID
	ID ULID `json:"_id"`
	// Information about what owns this emoji
	Parent CustomEmojiParent `json:"parent"`
	// Uploader user iD
	CreatorID ULID `json:"creator_id"`
	// Emoji name
	Name string `json:"name"`
	// Whether the emoji is animated
	Animated bool `json:"animated"`
	// Whether the emoji is marked as NSFW
	NSFW bool `json:"nsfw"`
}

type OptimizedCustomEmojiFlags int

const (
	OptimizedCustomEmojiFlagsAnimated OptimizedCustomEmojiFlags = 1 << (0 + iota)
	OptimizedCustomEmojiFlagsNSFW
)

type OptimizedCustomEmojiParentType int

const (
	OptimizedCustomEmojiParentTypeUnknown OptimizedCustomEmojiParentType = iota
	OptimizedCustomEmojiParentTypeServer
	OptimizedCustomEmojiParentTypeDetached
)

func (typ CustomEmojiParentType) ToOptimized() OptimizedCustomEmojiParentType {
	switch typ {
	case CustomEmojiParentTypeServer:
		return OptimizedCustomEmojiParentTypeServer
	case CustomEmojiParentTypeDetached:
		return OptimizedCustomEmojiParentTypeDetached
	default:
		return OptimizedCustomEmojiParentTypeUnknown
	}
}

type OptimizedCustomEmojiParent struct {
	Type OptimizedCustomEmojiParentType
	ID   ULID
}

func (o *CustomEmojiParent) ToOptimized() *OptimizedCustomEmojiParent {
	return &OptimizedCustomEmojiParent{
		Type: o.Type.ToOptimized(),
		ID:   o.ID,
	}
}

type OptimizedCustomEmoji struct {
	ID        ULID
	Parent    *OptimizedCustomEmojiParent
	CreatorID ULID
	Name      string
	Flags     OptimizedCustomEmojiFlags
}

func (e *CustomEmoji) ToOptimized() *OptimizedCustomEmoji {
	o := &OptimizedCustomEmoji{
		ID:        e.ID,
		Parent:    e.Parent.ToOptimized(),
		CreatorID: e.CreatorID,
		Name:      e.Name,
	}
	if e.Animated {
		o.Flags |= OptimizedCustomEmojiFlagsAnimated
	}
	if e.NSFW {
		o.Flags |= OptimizedCustomEmojiFlagsNSFW
	}
	return o
}

func (e OptimizedCustomEmoji) GetKey() ULID {
	return e.ID
}

type Account struct {
	ID    ULID   `json:"_id"`
	Email string `json:"email"`
}

type MFATicket struct {
	// Unique ID
	ID ULID `json:"_id"`
	// Account ID
	AccountID ULID `json:"account_id"`
	// Unique Token
	Token string `json:"token"`
	// Whether this ticket has been validated (can be used for account actions)
	Validated bool `json:"validated"`
	// Whether this ticket is authorised (can be used to log a user in)
	Authorised bool `json:"authorised"`
	// TOTP code at time of ticket creation
	LastTOTPCode string `json:"last_totp_code"`
}

type WebPushSubscription struct {
	Endpoint string `json:"endpoint"`
	P256DH   string `json:"p256dh"`
	Auth     string `json:"auth"`
}

type Session struct {
	ID   ULID   `json:"_id"`
	Name string `json:"name"`
}

// Composite primary key consisting of channel and user ID
type UnreadMessageID struct {
	// Channel ID
	Channel ULID `json:"channel"`
	// User ID
	User ULID `json:"user"`
}

type UnreadMessage struct {
	ID UnreadMessageID `json:"_id"`
	// ID of the last message read in this channel by a user
	LastID ULID `json:"last_id"`
	// Array of message IDs that mention the user
	Mentions []ULID `json:"mentions"`
}

type IndexAccesses struct {
	// Operations since timestamp
	Ops int `json:"ops"`
	// ISO8601 formatted timestamp
	Since time.Time `json:"since"`
}

type Index struct {
	// Index name
	Name string `json:"name"`
	// Index access information
	Accesses IndexAccesses `json:"accesses"`
}

type LatencyHistogramEntry struct {
	// Time
	Micros int64 `json:"micros"`
	// Count
	Count int64 `json:"count"`
}

type LatencyStats struct {
	// Total operations
	Ops int64 `json:"ops"`
	// Timestamp at which data keeping begun
	Latency int64 `json:"latency"`
	// Histogram representation of latency data
	Histogram []*LatencyHistogramEntry `json:"histogram"`
}

type CollectionScans struct {
	// Number of total collection scans
	Total int64 `json:"total"`
	// Number of total collection scans not using a tailable cursor
	NonTailable int64 `json:"nonTailable"`
}

type QueryExecStats struct {
	// Query collection scan stats
	CollectionScans CollectionScans `json:"collectionScans"`
}

type CollectionStats struct {
	// Namespace
	Namespace string    `json:"ns"`
	LocalTime time.Time `json:"localTime"`
	// Latency stats
	LatencyStats map[string]*LatencyStats `json:"latencyStats"`
	// Collection query execution stats
	QueryExecStats QueryExecStats `json:"queryExecStaus"`
	// Number of documents in collection
	Count uint64 `json:"count"`
}

type InstanceStatistics struct {
	// Index usage information
	Indices map[string]*Index `json:"indices"`
	// Collection stats
	CollStats map[string]*CollectionStats `json:"coll_stats"`
}

type ReportStatus string

const (
	ReportStatusCreated  ReportStatus = "Created"
	ReportStatusRejected ReportStatus = "Rejected"
	ReportStatusResolved ReportStatus = "Resolved"
)

type ReportContentType string

const (
	ReportContentTypeMessage ReportContentType = "Message"
	ReportContentTypeServer  ReportContentType = "Server"
	ReportContentTypeUser    ReportContentType = "User"
)

type ReportReason string

const (
	ReportReasonNoneSpecified        ReportReason = "NoneSpecified"
	ReportReasonIllegal              ReportReason = "Illegal"              // Message/Server
	ReportReasonIllegalGoods         ReportReason = "IllegalGoods"         // Message/Server
	ReportReasonIllegalExtortion     ReportReason = "IllegalExtortion"     // Message/Server
	ReportReasonIllegalPornography   ReportReason = "IllegalPornography"   // Message/Server
	ReportReasonIllegalHacking       ReportReason = "IllegalHacking"       // Message/Server
	ReportReasonExtremeViolence      ReportReason = "ExtremeViolence"      // Message/Server
	ReportReasonProtesHarm           ReportReason = "ProtesHarm"           // Message/Server
	ReportReasonUnsolicitedSpam      ReportReason = "UnsolicitedSpam"      // Message/Server/User
	ReportReasonRaid                 ReportReason = "Raid"                 // Message/Server
	ReportReasonSpamAbuse            ReportReason = "SpamAbuse"            // Message/Server/User
	ReportReasonScamsFraud           ReportReason = "ScamsFraud"           // Message/Server
	ReportReasonMalware              ReportReason = "Malware"              // Message/Server
	ReportReasonHarassment           ReportReason = "Harassment"           // Message/Server
	ReportReasonInappropriateProfile ReportReason = "InappropriateProfile" // User
	ReportReasonImpersonation        ReportReason = "Impersonation"        // User
	ReportReasonBanEvasion           ReportReason = "BanEvasion"           // User
	ReportReasonUnderage             ReportReason = "Underage"             // User
)

type ReportContent struct {
	Type ReportContentType `json:"type"`
	// ID of the message / ID of the server / ID of the user
	ID ULID `json:"id"`
	// Reason for reporting content (message or server)
	ReportReason ReportReason `json:"report_reason"`
	// Message context
	MessageID ULID `json:"message_id,omitempty"`
}

type Report struct {
	Status          ReportStatus `json:"status"`
	RejectionReason string       `json:"rejection_reason"`
	ClosedAt        *time.Time   `json:"closed_at"`
	// Unique ID
	ID ULID `json:"_id"`
	// ID of the user creating this report
	AuthorID ULID `json:"author_id"`
	// The content being reported
	Content ReportContent `json:"content"`
	// Additional report context
	AdditionalContext string `json:"additional_context"`
	// Additional notes included on the report
	Notes string `json:"notes"`
}

type SnapshotContentType string

const (
	SnapshotContentTypeMessage SnapshotContentType = "Message"
	SnapshotContentTypeServer  SnapshotContentType = "Server"
	SnapshotContentTypeUser    SnapshotContentType = "User"
)

type SnapshotContent struct {
	Type SnapshotContentType `json:"_type"`
	// [Message] Context before the message
	PriorContext []*Message `json:"_prior_context"`
	// [Message] Context after the message
	LeadingContext []*Message `json:"_leading_context"`
	// [Message,Server,User] Unique ID
	ID ULID `json:"_id"`
	// [Message] Unique value generated by client sending this message
	Nonce *string `json:"nonce"`
	// [Message] ID of the channel this message was sent in
	Channel ULID `json:"channel"`
	// [Message] ID of the user or webhook that sent this message
	Author ULID `json:"author"`
	// [Message] Information about the webhook bundled with Message
	Webhook *MessageWebhook `json:"webhook"`
	// [Message] Message content
	Content string `json:"content"`
	// [Message]
	System *SystemEventMessage `json:"system"`
	// [Message]
	Attachments []*AutumnFile `json:"attachments"`
	// [Message]
	Edited *time.Time `json:"edited"`
	// [Message] Attached embeds to this message
	Embeds []*Embed `json:"embeds"`
	// [Message] Array of user IDs mentioned in this message
	Mentions []ULID `json:"mentions"`
	// [Message] Array of message IDs this message is replyingto
	Replies []ULID `json:"replies"`
	// [Message] Hashmap of emoji IDs to array of user IDs
	Reactions map[string][]ULID `json:"reactions"`
	// [Message]
	Interactions *MessageInteractions `json:"interactions"`
	// [Message]
	Masquerade *Masquerade `json:"masquerade"`

	// [Server] User ID of the owner
	Owner ULID `json:"owner"`
	// [Server] Name of the server
	Name string `json:"name"`
	// [Server] Description for the server
	Description string `json:"description"`
	// [Server] Channels within this server
	Channels []ULID `json:"channels"`
	// [Server] Categories for this server
	Categories []*Category `json:"categories"`
	// [Server] System message channel assignments
	SystemMessages *SystemMessages `json:"system_messages"`
	// [Server] Roles for this server
	Roles map[ULID]*Role `json:"roles"`
	// [Server] Default set of server and channel permissions
	DefaultPermissions Permissions `json:"default_permissions"`
	// [Server]
	Icon *AutumnFile `json:"icon"`
	// [Server]
	Banner *AutumnFile `json:"banner"`
	// [Server,User] Bitfield of server flags / Enum of user flags
	Flags int `json:"flags"`
	// [Server] Whether this server is flagged as not safe for work
	NSFW bool `json:"nsfw"`
	// [Server] Whether to enable analytics
	Analytics bool `json:"analytics"`
	// [Server] Whether this server should be publicly discoverable
	Discoverable bool `json:"discoverable"`

	// [User] Username
	Username string `json:"username"`
	// [User] Discriminator
	Discriminator string `json:"discriminator"`
	// [User] Display name
	DisplayName string `json:"display_name"`
	// [User]
	Avatar *AutumnFile `json:"avatar"`
	// [User] Relationships with other users
	Relations []*UserRelation `json:"relations"`
	// [User] Bitfield of user badges
	Badges UserBadges `json:"badges"`
	// [User] User's active status
	Status *UserStatus `json:"status"`
	// [User] User's profile
	Profile *UserProfile `json:"profile"`
	// [Server,User] Bitfield of server flags / Enum of user flags
	// // Flags int `json:"flags"`

	// [User] Whether this user is privileged
	Privileged bool `json:"privileged"`
	// [User] Bot information for if the user is a bot
	Bot *UserBot `json:"bot"`
	// [User] User's relationship with another user (or themselves)
	Relationship RelationshipStatus `json:"relationship"`
	// [User] Whether this user is currently online
	Online bool `json:"online"`
}

func (sc *SnapshotContent) ToMessage() *Message {
	if sc.Type != SnapshotContentTypeMessage {
		return nil
	}
	return &Message{
		ID:           sc.ID,
		Nonce:        sc.Nonce,
		Channel:      sc.Channel,
		Author:       sc.Author,
		Webhook:      sc.Webhook,
		Content:      sc.Content,
		System:       sc.System,
		Attachments:  sc.Attachments,
		Edited:       sc.Edited,
		Embeds:       sc.Embeds,
		Mentions:     sc.Mentions,
		Replies:      sc.Replies,
		Reactions:    sc.Reactions,
		Interactions: sc.Interactions,
		Masquerade:   sc.Masquerade,
	}
}

func (sc *SnapshotContent) ToServer() *Server {
	if sc.Type != SnapshotContentTypeServer {
		return nil
	}
	return &Server{
		ID:                 sc.ID,
		Owner:              sc.Owner,
		Name:               sc.Name,
		Description:        sc.Description,
		Channels:           sc.Channels,
		Categories:         sc.Categories,
		SystemMessages:     sc.SystemMessages,
		Roles:              sc.Roles,
		DefaultPermissions: sc.DefaultPermissions,
		Icon:               sc.Icon,
		Banner:             sc.Banner,
		Flags:              ServerFlags(sc.Flags),
		NSFW:               sc.NSFW,
		Analytics:          sc.Analytics,
		Discoverable:       sc.Discoverable,
	}
}

func (sc *SnapshotContent) ToUser() *User {
	if sc.Type != SnapshotContentTypeUser {
		return nil
	}
	return &User{
		ID:            sc.ID,
		Username:      sc.Username,
		Discriminator: sc.Discriminator,
		DisplayName:   sc.DisplayName,
		Avatar:        sc.Avatar,
		Relations:     sc.Relations,
		Badges:        sc.Badges,
		Status:        sc.Status,
		Profile:       sc.Profile,
		Flags:         UserFlags(sc.Flags),
		Privileged:    sc.Privileged,
		Bot:           sc.Bot,
		Relationship:  sc.Relationship,
		Online:        sc.Online,
	}
}

type Snapshot struct {
	// Users involved in snapshot
	Users []*User `json:"_users"`
	// Channels involved in snapshot
	Channels []*Channel `json:"_channels"`
	Server   *Server    `json:"_server"`
	// Unique ID
	ID ULID `json:"_id"`
	// Report parent ID
	ReportID ULID `json:"report_id"`
	// Enum to map into different models that can be saved in a snapshot
	Content *SnapshotContent `json:"content"`
}

type Strike struct {
	// Strike ID
	ID ULID `json:"_id"`
	// ID of reported user
	UserID ULID `json:"user_id"`
	// Attached reason
	Reason string `json:"reason"`
}

type Setting struct {
	Timestamp int64
	Value     string
}

func (s *Setting) UnmarshalJSON(d []byte) (err error) {
	var a [2]json.RawMessage
	err = json.Unmarshal(d, &a)
	if err != nil {
		return
	}
	err = json.Unmarshal(a[0], &s.Timestamp)
	if err == nil {
		err = json.Unmarshal(a[1], &s.Value)
	}
	return
}
